{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WidgetParser = void 0;\nvar _Widget = require(\"./Widget\");\nvar _url = require(\"./validation/url\");\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (!it) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function F() {};\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n} /*\n   * Copyright 2020 The Matrix.org Foundation C.I.C.\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *         http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\nvar WidgetParser = /*#__PURE__*/function () {\n  function WidgetParser() {\n    _classCallCheck(this, WidgetParser);\n  } // private constructor because this is a util class\n\n  /**\n   * Parses widgets from the \"m.widgets\" account data event. This will always\n   * return an array, though may be empty if no valid widgets were found.\n   * @param {IAccountDataWidgets} content The content of the \"m.widgets\" account data.\n   * @returns {Widget[]} The widgets in account data, or an empty array.\n   */\n  _createClass(WidgetParser, null, [{\n    key: \"parseAccountData\",\n    value: function parseAccountData(content) {\n      if (!content) return [];\n      var result = [];\n      for (var _i = 0, _Object$keys = Object.keys(content); _i < _Object$keys.length; _i++) {\n        var _widgetId = _Object$keys[_i];\n        var roughWidget = content[_widgetId];\n        if (!roughWidget) continue;\n        if (roughWidget.type !== \"m.widget\" && roughWidget.type !== \"im.vector.modular.widgets\") continue;\n        if (!roughWidget.sender) continue;\n        var probableWidgetId = roughWidget.state_key || roughWidget.id;\n        if (probableWidgetId !== _widgetId) continue;\n        var asStateEvent = {\n          content: roughWidget.content,\n          sender: roughWidget.sender,\n          type: \"m.widget\",\n          state_key: _widgetId,\n          event_id: \"$example\",\n          room_id: \"!example\",\n          origin_server_ts: 1\n        };\n        var widget = WidgetParser.parseRoomWidget(asStateEvent);\n        if (widget) result.push(widget);\n      }\n      return result;\n    }\n\n    /**\n     * Parses all the widgets possible in the given array. This will always return\n     * an array, though may be empty if no widgets could be parsed.\n     * @param {IStateEvent[]} currentState The room state to parse.\n     * @returns {Widget[]} The widgets in the state, or an empty array.\n     */\n  }, {\n    key: \"parseWidgetsFromRoomState\",\n    value: function parseWidgetsFromRoomState(currentState) {\n      if (!currentState) return [];\n      var result = [];\n      var _iterator = _createForOfIteratorHelper(currentState),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var state = _step.value;\n          var widget = WidgetParser.parseRoomWidget(state);\n          if (widget) result.push(widget);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return result;\n    }\n\n    /**\n     * Parses a state event into a widget. If the state event does not represent\n     * a widget (wrong event type, invalid widget, etc) then null is returned.\n     * @param {IStateEvent} stateEvent The state event.\n     * @returns {Widget|null} The widget, or null if invalid\n     */\n  }, {\n    key: \"parseRoomWidget\",\n    value: function parseRoomWidget(stateEvent) {\n      if (!stateEvent) return null;\n\n      // TODO: [Legacy] Remove legacy support\n      if (stateEvent.type !== \"m.widget\" && stateEvent.type !== \"im.vector.modular.widgets\") {\n        return null;\n      }\n\n      // Dev note: Throughout this function we have null safety to ensure that\n      // if the caller did not supply something useful that we don't error. This\n      // is done against the requirements of the interface because not everyone\n      // will have an interface to validate against.\n\n      var content = stateEvent.content || {};\n\n      // Form our best approximation of a widget with the information we have\n      var estimatedWidget = {\n        id: stateEvent.state_key,\n        creatorUserId: content[\"creatorUserId\"] || stateEvent.sender,\n        name: content[\"name\"],\n        type: content[\"type\"],\n        url: content[\"url\"],\n        waitForIframeLoad: content[\"waitForIframeLoad\"],\n        data: content[\"data\"]\n      };\n\n      // Finally, process that widget\n      return WidgetParser.processEstimatedWidget(estimatedWidget);\n    }\n  }, {\n    key: \"processEstimatedWidget\",\n    value: function processEstimatedWidget(widget) {\n      // Validate that the widget has the best chance of passing as a widget\n      if (!widget.id || !widget.creatorUserId || !widget.type) {\n        return null;\n      }\n      if (!(0, _url.isValidUrl)(widget.url)) {\n        return null;\n      }\n      // TODO: Validate data for known widget types\n      return new _Widget.Widget(widget);\n    }\n  }]);\n  return WidgetParser;\n}();\nexports.WidgetParser = WidgetParser;","map":{"version":3,"names":["_Widget","require","_url","_typeof","obj","Symbol","iterator","constructor","prototype","_createForOfIteratorHelper","o","allowArrayLike","it","Array","isArray","_unsupportedIterableToArray","length","i","F","s","n","done","value","e","_e","f","TypeError","normalCompletion","didErr","err","call","step","next","_e2","minLen","_arrayLikeToArray","Object","toString","slice","name","from","test","arr","len","arr2","_classCallCheck","instance","Constructor","_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","_toPropertyKey","key","_createClass","protoProps","staticProps","arg","_toPrimitive","String","input","hint","prim","toPrimitive","undefined","res","Number","WidgetParser","parseAccountData","content","result","_i","_Object$keys","keys","_widgetId","roughWidget","type","sender","probableWidgetId","state_key","id","asStateEvent","event_id","room_id","origin_server_ts","widget","parseRoomWidget","push","parseWidgetsFromRoomState","currentState","_iterator","_step","state","stateEvent","estimatedWidget","creatorUserId","url","waitForIframeLoad","data","processEstimatedWidget","isValidUrl","Widget","exports"],"sources":["C:\\Users\\pilat\\Documents\\Knwlab\\matrix-bot-widget\\node_modules\\matrix-widget-api\\src\\models\\WidgetParser.ts"],"sourcesContent":["/*\n * Copyright 2020 The Matrix.org Foundation C.I.C.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Widget } from \"./Widget\";\nimport { IWidget } from \"..\";\nimport { isValidUrl } from \"./validation/url\";\n\nexport interface IStateEvent {\n    event_id: string; // eslint-disable-line camelcase\n    room_id: string; // eslint-disable-line camelcase\n    type: string;\n    sender: string;\n    origin_server_ts: number; // eslint-disable-line camelcase\n    unsigned?: unknown;\n    content: unknown;\n    state_key: string; // eslint-disable-line camelcase\n}\n\nexport interface IAccountDataWidgets {\n    [widgetId: string]: {\n        type: \"m.widget\";\n        // the state_key is also the widget's ID\n        state_key: string; // eslint-disable-line camelcase\n        sender: string; // current user's ID\n        content: IWidget;\n        id?: string; // off-spec, but possible\n    };\n}\n\nexport class WidgetParser {\n    private constructor() {\n        // private constructor because this is a util class\n    }\n\n    /**\n     * Parses widgets from the \"m.widgets\" account data event. This will always\n     * return an array, though may be empty if no valid widgets were found.\n     * @param {IAccountDataWidgets} content The content of the \"m.widgets\" account data.\n     * @returns {Widget[]} The widgets in account data, or an empty array.\n     */\n    public static parseAccountData(content: IAccountDataWidgets): Widget[] {\n        if (!content) return [];\n\n        const result: Widget[] = [];\n        for (const widgetId of Object.keys(content)) {\n            const roughWidget = content[widgetId];\n            if (!roughWidget) continue;\n            if (roughWidget.type !== \"m.widget\" && roughWidget.type !== \"im.vector.modular.widgets\") continue;\n            if (!roughWidget.sender) continue;\n\n            const probableWidgetId = roughWidget.state_key || roughWidget.id;\n            if (probableWidgetId !== widgetId) continue;\n\n            const asStateEvent: IStateEvent = {\n                content: roughWidget.content,\n                sender: roughWidget.sender,\n                type: \"m.widget\",\n                state_key: widgetId,\n                event_id: \"$example\",\n                room_id: \"!example\",\n                origin_server_ts: 1,\n            };\n\n            const widget = WidgetParser.parseRoomWidget(asStateEvent);\n            if (widget) result.push(widget);\n        }\n\n        return result;\n    }\n\n    /**\n     * Parses all the widgets possible in the given array. This will always return\n     * an array, though may be empty if no widgets could be parsed.\n     * @param {IStateEvent[]} currentState The room state to parse.\n     * @returns {Widget[]} The widgets in the state, or an empty array.\n     */\n    public static parseWidgetsFromRoomState(currentState: IStateEvent[]): Widget[] {\n        if (!currentState) return [];\n        const result: Widget[] = [];\n        for (const state of currentState) {\n            const widget = WidgetParser.parseRoomWidget(state);\n            if (widget) result.push(widget);\n        }\n        return result;\n    }\n\n    /**\n     * Parses a state event into a widget. If the state event does not represent\n     * a widget (wrong event type, invalid widget, etc) then null is returned.\n     * @param {IStateEvent} stateEvent The state event.\n     * @returns {Widget|null} The widget, or null if invalid\n     */\n    public static parseRoomWidget(stateEvent: IStateEvent): Widget | null {\n        if (!stateEvent) return null;\n\n        // TODO: [Legacy] Remove legacy support\n        if (stateEvent.type !== \"m.widget\" && stateEvent.type !== \"im.vector.modular.widgets\") {\n            return null;\n        }\n\n        // Dev note: Throughout this function we have null safety to ensure that\n        // if the caller did not supply something useful that we don't error. This\n        // is done against the requirements of the interface because not everyone\n        // will have an interface to validate against.\n\n        const content = (stateEvent.content as IWidget) || {};\n\n        // Form our best approximation of a widget with the information we have\n        const estimatedWidget: IWidget = {\n            id: stateEvent.state_key,\n            creatorUserId: content[\"creatorUserId\"] || stateEvent.sender,\n            name: content[\"name\"],\n            type: content[\"type\"],\n            url: content[\"url\"],\n            waitForIframeLoad: content[\"waitForIframeLoad\"],\n            data: content[\"data\"],\n        };\n\n        // Finally, process that widget\n        return WidgetParser.processEstimatedWidget(estimatedWidget);\n    }\n\n    private static processEstimatedWidget(widget: IWidget): Widget | null {\n        // Validate that the widget has the best chance of passing as a widget\n        if (!widget.id || !widget.creatorUserId || !widget.type) {\n            return null;\n        }\n        if (!isValidUrl(widget.url)) {\n            return null;\n        }\n        // TODO: Validate data for known widget types\n        return new Widget(widget);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}