{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WidgetEventCapability = exports.EventKind = exports.EventDirection = void 0;\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (!it) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function F() {};\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\n/*\n * Copyright 2020 The Matrix.org Foundation C.I.C.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar EventKind = /*#__PURE__*/function (EventKind) {\n  EventKind[\"Event\"] = \"event\";\n  EventKind[\"State\"] = \"state_event\";\n  EventKind[\"ToDevice\"] = \"to_device\";\n  EventKind[\"RoomAccount\"] = \"room_account\";\n  return EventKind;\n}({});\nexports.EventKind = EventKind;\nvar EventDirection = /*#__PURE__*/function (EventDirection) {\n  EventDirection[\"Send\"] = \"send\";\n  EventDirection[\"Receive\"] = \"receive\";\n  return EventDirection;\n}({});\nexports.EventDirection = EventDirection;\nvar WidgetEventCapability = /*#__PURE__*/function () {\n  function WidgetEventCapability(direction, eventType, kind, keyStr, raw) {\n    _classCallCheck(this, WidgetEventCapability);\n    this.direction = direction;\n    this.eventType = eventType;\n    this.kind = kind;\n    this.keyStr = keyStr;\n    this.raw = raw;\n  }\n  _createClass(WidgetEventCapability, [{\n    key: \"matchesAsStateEvent\",\n    value: function matchesAsStateEvent(direction, eventType, stateKey) {\n      if (this.kind !== EventKind.State) return false; // not a state event\n      if (this.direction !== direction) return false; // direction mismatch\n      if (this.eventType !== eventType) return false; // event type mismatch\n      if (this.keyStr === null) return true; // all state keys are allowed\n      if (this.keyStr === stateKey) return true; // this state key is allowed\n\n      // Default not allowed\n      return false;\n    }\n  }, {\n    key: \"matchesAsToDeviceEvent\",\n    value: function matchesAsToDeviceEvent(direction, eventType) {\n      if (this.kind !== EventKind.ToDevice) return false; // not a to-device event\n      if (this.direction !== direction) return false; // direction mismatch\n      if (this.eventType !== eventType) return false; // event type mismatch\n\n      // Checks passed, the event is allowed\n      return true;\n    }\n  }, {\n    key: \"matchesAsRoomEvent\",\n    value: function matchesAsRoomEvent(direction, eventType) {\n      var msgtype = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      if (this.kind !== EventKind.Event) return false; // not a room event\n      if (this.direction !== direction) return false; // direction mismatch\n      if (this.eventType !== eventType) return false; // event type mismatch\n\n      if (this.eventType === \"m.room.message\") {\n        if (this.keyStr === null) return true; // all message types are allowed\n        if (this.keyStr === msgtype) return true; // this message type is allowed\n      } else {\n        return true; // already passed the check for if the event is allowed\n      }\n\n      // Default not allowed\n      return false;\n    }\n  }, {\n    key: \"matchesAsRoomAccountData\",\n    value: function matchesAsRoomAccountData(direction, eventType) {\n      if (this.kind !== EventKind.RoomAccount) return false; // not room account data\n      if (this.direction !== direction) return false; // direction mismatch\n      if (this.eventType !== eventType) return false; // event type mismatch\n\n      // Checks passed, the event is allowed\n      return true;\n    }\n  }], [{\n    key: \"forStateEvent\",\n    value: function forStateEvent(direction, eventType, stateKey) {\n      // TODO: Enable support for m.* namespace once the MSC lands.\n      // https://github.com/matrix-org/matrix-widget-api/issues/22\n      eventType = eventType.replace(/#/g, \"\\\\#\");\n      stateKey = stateKey !== null && stateKey !== undefined ? \"#\".concat(stateKey) : \"\";\n      var str = \"org.matrix.msc2762.\".concat(direction, \".state_event:\").concat(eventType).concat(stateKey);\n\n      // cheat by sending it through the processor\n      return WidgetEventCapability.findEventCapabilities([str])[0];\n    }\n  }, {\n    key: \"forToDeviceEvent\",\n    value: function forToDeviceEvent(direction, eventType) {\n      // TODO: Enable support for m.* namespace once the MSC lands.\n      // https://github.com/matrix-org/matrix-widget-api/issues/56\n      var str = \"org.matrix.msc3819.\".concat(direction, \".to_device:\").concat(eventType);\n\n      // cheat by sending it through the processor\n      return WidgetEventCapability.findEventCapabilities([str])[0];\n    }\n  }, {\n    key: \"forRoomEvent\",\n    value: function forRoomEvent(direction, eventType) {\n      // TODO: Enable support for m.* namespace once the MSC lands.\n      // https://github.com/matrix-org/matrix-widget-api/issues/22\n      var str = \"org.matrix.msc2762.\".concat(direction, \".event:\").concat(eventType);\n\n      // cheat by sending it through the processor\n      return WidgetEventCapability.findEventCapabilities([str])[0];\n    }\n  }, {\n    key: \"forRoomMessageEvent\",\n    value: function forRoomMessageEvent(direction, msgtype) {\n      // TODO: Enable support for m.* namespace once the MSC lands.\n      // https://github.com/matrix-org/matrix-widget-api/issues/22\n      msgtype = msgtype === null || msgtype === undefined ? \"\" : msgtype;\n      var str = \"org.matrix.msc2762.\".concat(direction, \".event:m.room.message#\").concat(msgtype);\n\n      // cheat by sending it through the processor\n      return WidgetEventCapability.findEventCapabilities([str])[0];\n    }\n  }, {\n    key: \"forRoomAccountData\",\n    value: function forRoomAccountData(direction, eventType) {\n      var str = \"com.beeper.capabilities.\".concat(direction, \".room_account_data:\").concat(eventType);\n      return WidgetEventCapability.findEventCapabilities([str])[0];\n    }\n\n    /**\n     * Parses a capabilities request to find all the event capability requests.\n     * @param {Iterable<Capability>} capabilities The capabilities requested/to parse.\n     * @returns {WidgetEventCapability[]} An array of event capability requests. May be empty, but never null.\n     */\n  }, {\n    key: \"findEventCapabilities\",\n    value: function findEventCapabilities(capabilities) {\n      var parsed = [];\n      var _iterator = _createForOfIteratorHelper(capabilities),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var cap = _step.value;\n          var _direction = null;\n          var eventSegment = void 0;\n          var _kind = null;\n\n          // TODO: Enable support for m.* namespace once the MSCs land.\n          // https://github.com/matrix-org/matrix-widget-api/issues/22\n          // https://github.com/matrix-org/matrix-widget-api/issues/56\n\n          if (cap.startsWith(\"org.matrix.msc2762.send.event:\")) {\n            _direction = EventDirection.Send;\n            _kind = EventKind.Event;\n            eventSegment = cap.substring(\"org.matrix.msc2762.send.event:\".length);\n          } else if (cap.startsWith(\"org.matrix.msc2762.send.state_event:\")) {\n            _direction = EventDirection.Send;\n            _kind = EventKind.State;\n            eventSegment = cap.substring(\"org.matrix.msc2762.send.state_event:\".length);\n          } else if (cap.startsWith(\"org.matrix.msc3819.send.to_device:\")) {\n            _direction = EventDirection.Send;\n            _kind = EventKind.ToDevice;\n            eventSegment = cap.substring(\"org.matrix.msc3819.send.to_device:\".length);\n          } else if (cap.startsWith(\"org.matrix.msc2762.receive.event:\")) {\n            _direction = EventDirection.Receive;\n            _kind = EventKind.Event;\n            eventSegment = cap.substring(\"org.matrix.msc2762.receive.event:\".length);\n          } else if (cap.startsWith(\"org.matrix.msc2762.receive.state_event:\")) {\n            _direction = EventDirection.Receive;\n            _kind = EventKind.State;\n            eventSegment = cap.substring(\"org.matrix.msc2762.receive.state_event:\".length);\n          } else if (cap.startsWith(\"org.matrix.msc3819.receive.to_device:\")) {\n            _direction = EventDirection.Receive;\n            _kind = EventKind.ToDevice;\n            eventSegment = cap.substring(\"org.matrix.msc3819.receive.to_device:\".length);\n          } else if (cap.startsWith(\"com.beeper.capabilities.receive.room_account_data:\")) {\n            _direction = EventDirection.Receive;\n            _kind = EventKind.RoomAccount;\n            eventSegment = cap.substring(\"com.beeper.capabilities.receive.room_account_data:\".length);\n          }\n          if (_direction === null || _kind === null || eventSegment === undefined) continue;\n\n          // The capability uses `#` as a separator between event type and state key/msgtype,\n          // so we split on that. However, a # is also valid in either one of those so we\n          // join accordingly.\n          // Eg: `m.room.message##m.text` is \"m.room.message\" event with msgtype \"#m.text\".\n          var expectingKeyStr = eventSegment.startsWith(\"m.room.message#\") || _kind === EventKind.State;\n          var _keyStr = null;\n          if (eventSegment.includes(\"#\") && expectingKeyStr) {\n            // Dev note: regex is difficult to write, so instead the rules are manually written\n            // out. This is probably just as understandable as a boring regex though, so win-win?\n\n            // Test cases:\n            // str                      eventSegment        keyStr\n            // -------------------------------------------------------------\n            // m.room.message#          m.room.message      <empty string>\n            // m.room.message#test      m.room.message      test\n            // m.room.message\\#         m.room.message#     test\n            // m.room.message##test     m.room.message      #test\n            // m.room.message\\##test    m.room.message#     test\n            // m.room.message\\\\##test   m.room.message\\#    test\n            // m.room.message\\\\###test  m.room.message\\#    #test\n\n            // First step: explode the string\n            var parts = eventSegment.split(\"#\");\n\n            // To form the eventSegment, we'll keep finding parts of the exploded string until\n            // there's one that doesn't end with the escape character (\\). We'll then join those\n            // segments together with the exploding character. We have to remember to consume the\n            // escape character as well.\n            var idx = parts.findIndex(function (p) {\n              return !p.endsWith(\"\\\\\");\n            });\n            eventSegment = parts.slice(0, idx + 1).map(function (p) {\n              return p.endsWith(\"\\\\\") ? p.substring(0, p.length - 1) : p;\n            }).join(\"#\");\n\n            // The keyStr is whatever is left over.\n            _keyStr = parts.slice(idx + 1).join(\"#\");\n          }\n          parsed.push(new WidgetEventCapability(_direction, eventSegment, _kind, _keyStr, cap));\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return parsed;\n    }\n  }]);\n  return WidgetEventCapability;\n}();\nexports.WidgetEventCapability = WidgetEventCapability;","map":{"version":3,"names":["EventKind","exports","EventDirection","WidgetEventCapability","direction","eventType","kind","keyStr","raw","_classCallCheck","_createClass","key","value","matchesAsStateEvent","stateKey","State","matchesAsToDeviceEvent","ToDevice","matchesAsRoomEvent","msgtype","arguments","length","undefined","Event","matchesAsRoomAccountData","RoomAccount","forStateEvent","replace","concat","str","findEventCapabilities","forToDeviceEvent","forRoomEvent","forRoomMessageEvent","forRoomAccountData","capabilities","parsed","_iterator","_createForOfIteratorHelper","_step","s","n","done","cap","_direction","eventSegment","_kind","startsWith","Send","substring","Receive","expectingKeyStr","_keyStr","includes","parts","split","idx","findIndex","p","endsWith","slice","map","join","push","err","e","f"],"sources":["C:\\Users\\pilat\\Documents\\Knwlab\\matrix-bot-widget\\node_modules\\matrix-widget-api\\src\\models\\WidgetEventCapability.ts"],"sourcesContent":["/*\n * Copyright 2020 The Matrix.org Foundation C.I.C.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Capability } from \"..\";\n\nexport enum EventKind {\n    Event = \"event\",\n    State = \"state_event\",\n    ToDevice = \"to_device\",\n    RoomAccount = \"room_account\",\n}\n\nexport enum EventDirection {\n    Send = \"send\",\n    Receive = \"receive\",\n}\n\nexport class WidgetEventCapability {\n    private constructor(\n        public readonly direction: EventDirection,\n        public readonly eventType: string,\n        public readonly kind: EventKind,\n        public readonly keyStr: string | null,\n        public readonly raw: string,\n    ) {}\n\n    public matchesAsStateEvent(direction: EventDirection, eventType: string, stateKey: string | null): boolean {\n        if (this.kind !== EventKind.State) return false; // not a state event\n        if (this.direction !== direction) return false; // direction mismatch\n        if (this.eventType !== eventType) return false; // event type mismatch\n        if (this.keyStr === null) return true; // all state keys are allowed\n        if (this.keyStr === stateKey) return true; // this state key is allowed\n\n        // Default not allowed\n        return false;\n    }\n\n    public matchesAsToDeviceEvent(direction: EventDirection, eventType: string): boolean {\n        if (this.kind !== EventKind.ToDevice) return false; // not a to-device event\n        if (this.direction !== direction) return false; // direction mismatch\n        if (this.eventType !== eventType) return false; // event type mismatch\n\n        // Checks passed, the event is allowed\n        return true;\n    }\n\n    public matchesAsRoomEvent(direction: EventDirection, eventType: string, msgtype: string | null = null): boolean {\n        if (this.kind !== EventKind.Event) return false; // not a room event\n        if (this.direction !== direction) return false; // direction mismatch\n        if (this.eventType !== eventType) return false; // event type mismatch\n\n        if (this.eventType === \"m.room.message\") {\n            if (this.keyStr === null) return true; // all message types are allowed\n            if (this.keyStr === msgtype) return true; // this message type is allowed\n        } else {\n            return true; // already passed the check for if the event is allowed\n        }\n\n        // Default not allowed\n        return false;\n    }\n\n    public matchesAsRoomAccountData(direction: EventDirection, eventType: string): boolean {\n        if (this.kind !== EventKind.RoomAccount) return false; // not room account data\n        if (this.direction !== direction) return false; // direction mismatch\n        if (this.eventType !== eventType) return false; // event type mismatch\n\n        // Checks passed, the event is allowed\n        return true;\n    }\n\n    public static forStateEvent(\n        direction: EventDirection,\n        eventType: string,\n        stateKey?: string,\n    ): WidgetEventCapability {\n        // TODO: Enable support for m.* namespace once the MSC lands.\n        // https://github.com/matrix-org/matrix-widget-api/issues/22\n        eventType = eventType.replace(/#/g, \"\\\\#\");\n        stateKey = stateKey !== null && stateKey !== undefined ? `#${stateKey}` : \"\";\n        const str = `org.matrix.msc2762.${direction}.state_event:${eventType}${stateKey}`;\n\n        // cheat by sending it through the processor\n        return WidgetEventCapability.findEventCapabilities([str])[0];\n    }\n\n    public static forToDeviceEvent(direction: EventDirection, eventType: string): WidgetEventCapability {\n        // TODO: Enable support for m.* namespace once the MSC lands.\n        // https://github.com/matrix-org/matrix-widget-api/issues/56\n        const str = `org.matrix.msc3819.${direction}.to_device:${eventType}`;\n\n        // cheat by sending it through the processor\n        return WidgetEventCapability.findEventCapabilities([str])[0];\n    }\n\n    public static forRoomEvent(direction: EventDirection, eventType: string): WidgetEventCapability {\n        // TODO: Enable support for m.* namespace once the MSC lands.\n        // https://github.com/matrix-org/matrix-widget-api/issues/22\n        const str = `org.matrix.msc2762.${direction}.event:${eventType}`;\n\n        // cheat by sending it through the processor\n        return WidgetEventCapability.findEventCapabilities([str])[0];\n    }\n\n    public static forRoomMessageEvent(direction: EventDirection, msgtype?: string): WidgetEventCapability {\n        // TODO: Enable support for m.* namespace once the MSC lands.\n        // https://github.com/matrix-org/matrix-widget-api/issues/22\n        msgtype = msgtype === null || msgtype === undefined ? \"\" : msgtype;\n        const str = `org.matrix.msc2762.${direction}.event:m.room.message#${msgtype}`;\n\n        // cheat by sending it through the processor\n        return WidgetEventCapability.findEventCapabilities([str])[0];\n    }\n\n    public static forRoomAccountData(direction: EventDirection, eventType: string): WidgetEventCapability {\n        const str = `com.beeper.capabilities.${direction}.room_account_data:${eventType}`;\n\n        return WidgetEventCapability.findEventCapabilities([str])[0];\n    }\n\n    /**\n     * Parses a capabilities request to find all the event capability requests.\n     * @param {Iterable<Capability>} capabilities The capabilities requested/to parse.\n     * @returns {WidgetEventCapability[]} An array of event capability requests. May be empty, but never null.\n     */\n    public static findEventCapabilities(capabilities: Iterable<Capability>): WidgetEventCapability[] {\n        const parsed: WidgetEventCapability[] = [];\n        for (const cap of capabilities) {\n            let direction: EventDirection | null = null;\n            let eventSegment: string | undefined;\n            let kind: EventKind | null = null;\n\n            // TODO: Enable support for m.* namespace once the MSCs land.\n            // https://github.com/matrix-org/matrix-widget-api/issues/22\n            // https://github.com/matrix-org/matrix-widget-api/issues/56\n\n            if (cap.startsWith(\"org.matrix.msc2762.send.event:\")) {\n                direction = EventDirection.Send;\n                kind = EventKind.Event;\n                eventSegment = cap.substring(\"org.matrix.msc2762.send.event:\".length);\n            } else if (cap.startsWith(\"org.matrix.msc2762.send.state_event:\")) {\n                direction = EventDirection.Send;\n                kind = EventKind.State;\n                eventSegment = cap.substring(\"org.matrix.msc2762.send.state_event:\".length);\n            } else if (cap.startsWith(\"org.matrix.msc3819.send.to_device:\")) {\n                direction = EventDirection.Send;\n                kind = EventKind.ToDevice;\n                eventSegment = cap.substring(\"org.matrix.msc3819.send.to_device:\".length);\n            } else if (cap.startsWith(\"org.matrix.msc2762.receive.event:\")) {\n                direction = EventDirection.Receive;\n                kind = EventKind.Event;\n                eventSegment = cap.substring(\"org.matrix.msc2762.receive.event:\".length);\n            } else if (cap.startsWith(\"org.matrix.msc2762.receive.state_event:\")) {\n                direction = EventDirection.Receive;\n                kind = EventKind.State;\n                eventSegment = cap.substring(\"org.matrix.msc2762.receive.state_event:\".length);\n            } else if (cap.startsWith(\"org.matrix.msc3819.receive.to_device:\")) {\n                direction = EventDirection.Receive;\n                kind = EventKind.ToDevice;\n                eventSegment = cap.substring(\"org.matrix.msc3819.receive.to_device:\".length);\n            } else if (cap.startsWith(\"com.beeper.capabilities.receive.room_account_data:\")) {\n                direction = EventDirection.Receive;\n                kind = EventKind.RoomAccount;\n                eventSegment = cap.substring(\"com.beeper.capabilities.receive.room_account_data:\".length);\n            }\n\n            if (direction === null || kind === null || eventSegment === undefined) continue;\n\n            // The capability uses `#` as a separator between event type and state key/msgtype,\n            // so we split on that. However, a # is also valid in either one of those so we\n            // join accordingly.\n            // Eg: `m.room.message##m.text` is \"m.room.message\" event with msgtype \"#m.text\".\n            const expectingKeyStr = eventSegment.startsWith(\"m.room.message#\") || kind === EventKind.State;\n            let keyStr: string | null = null;\n            if (eventSegment.includes(\"#\") && expectingKeyStr) {\n                // Dev note: regex is difficult to write, so instead the rules are manually written\n                // out. This is probably just as understandable as a boring regex though, so win-win?\n\n                // Test cases:\n                // str                      eventSegment        keyStr\n                // -------------------------------------------------------------\n                // m.room.message#          m.room.message      <empty string>\n                // m.room.message#test      m.room.message      test\n                // m.room.message\\#         m.room.message#     test\n                // m.room.message##test     m.room.message      #test\n                // m.room.message\\##test    m.room.message#     test\n                // m.room.message\\\\##test   m.room.message\\#    test\n                // m.room.message\\\\###test  m.room.message\\#    #test\n\n                // First step: explode the string\n                const parts = eventSegment.split(\"#\");\n\n                // To form the eventSegment, we'll keep finding parts of the exploded string until\n                // there's one that doesn't end with the escape character (\\). We'll then join those\n                // segments together with the exploding character. We have to remember to consume the\n                // escape character as well.\n                const idx = parts.findIndex((p) => !p.endsWith(\"\\\\\"));\n                eventSegment = parts\n                    .slice(0, idx + 1)\n                    .map((p) => (p.endsWith(\"\\\\\") ? p.substring(0, p.length - 1) : p))\n                    .join(\"#\");\n\n                // The keyStr is whatever is left over.\n                keyStr = parts.slice(idx + 1).join(\"#\");\n            }\n\n            parsed.push(new WidgetEventCapability(direction, eventSegment, kind, keyStr, cap));\n        }\n        return parsed;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}