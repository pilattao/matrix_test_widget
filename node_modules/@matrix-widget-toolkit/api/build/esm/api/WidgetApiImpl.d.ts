import { Capability, IDownloadFileActionFromWidgetResponseData, IGetMediaConfigActionFromWidgetResponseData, IModalWidgetCreateData, IModalWidgetOpenRequestDataButton, IModalWidgetReturnData, IOpenIDCredentials, ISendEventFromWidgetResponseData, IUploadFileActionFromWidgetResponseData, IWidgetApiRequestData, WidgetApi as MatrixWidgetApi, ModalButtonID, Symbols, UpdateDelayedEventAction, WidgetEventCapability } from 'matrix-widget-api';
import { Observable } from 'rxjs';
import { RoomEvent, StateEvent, ToDeviceMessageEvent, TurnServer, WidgetApi, WidgetConfig, WidgetParameters } from './types';
/**
 * Options for the {@link WidgetApiImpl.create} function.
 */
export type WidgetApiOptions = {
    /**
     * Optional initial capabilities that should be requested from the user on
     * load.
     */
    capabilities?: Array<WidgetEventCapability | Capability>;
    /**
     * Enable the the pop-out button for pinned widgets that support running
     * without the Widget API.
     */
    supportStandalone?: boolean;
};
/**
 * Implementation of the API from the widget to the client.
 *
 * @remarks Widget API is specified here:
 * https://docs.google.com/document/d/1uPF7XWY_dXTKVKV7jZQ2KmsI19wn9-kFRgQ1tFQP7wQ/edit#heading=h.9rn9lt6ctkgi
 */
export declare class WidgetApiImpl implements WidgetApi {
    /**
     * Provide access to the underlying widget API from `matrix-widget-sdk`.
     *
     * @remarks Normally there is no need to use it, however if features are
     *          missing from `WidgetApi` it can be handy to work with the
     *          original API.
     */
    readonly matrixWidgetApi: MatrixWidgetApi;
    /** {@inheritDoc WidgetApi.widgetId} */
    readonly widgetId: string;
    /** {@inheritDoc WidgetApi.widgetParameters} */
    readonly widgetParameters: WidgetParameters;
    /**
     * Initialize a new widget API instance and wait till it is ready.
     * There should only be one instance of the widget API. The widget API should
     * be created as early as possible when starting the application. This is
     * required to match the timing of the API connection establishment with the
     * client, especially in Safari. Therefore it is recommended to create it
     * inside the entrypoint, before initializing rendering engines like react.
     *
     * @param param0 - {@link WidgetApiOptions}
     *
     * @returns A widget API instance ready to use.
     */
    static create({ capabilities, supportStandalone, }?: WidgetApiOptions): Promise<WidgetApi>;
    private widgetConfig;
    private outstandingCapabilitiesRequest;
    private outstandingOpenIDConnectTokenRequest;
    private cachedOpenIdToken;
    private readonly events$;
    private readonly toDeviceMessages$;
    private readonly initialCapabilities;
    constructor(
    /**
     * Provide access to the underlying widget API from `matrix-widget-sdk`.
     *
     * @remarks Normally there is no need to use it, however if features are
     *          missing from `WidgetApi` it can be handy to work with the
     *          original API.
     */
    matrixWidgetApi: MatrixWidgetApi, 
    /** {@inheritDoc WidgetApi.widgetId} */
    widgetId: string, 
    /** {@inheritDoc WidgetApi.widgetParameters} */
    widgetParameters: WidgetParameters, { capabilities, supportStandalone }?: WidgetApiOptions);
    /**
     * Initialize the widget API and wait till a connection with the client is
     * fully established.
     *
     * Waits till the user has approved the initial set of capabilities. The
     * method doesn't fail if the user doesn't approve all of them. It is
     * required to check manually afterwards.
     * In case of modal widgets it waits till the `widgetConfig` is received.
     *
     * @remarks Should only be called once during startup.
     */
    initialize(): Promise<void>;
    /** {@inheritDoc WidgetApi.getWidgetConfig} */
    getWidgetConfig<T extends IWidgetApiRequestData>(): Readonly<WidgetConfig<T> | undefined>;
    /** {@inheritDoc WidgetApi.rerequestInitialCapabilities} */
    rerequestInitialCapabilities(): Promise<void>;
    /** {@inheritDoc WidgetApi.hasInitialCapabilities} */
    hasInitialCapabilities(): boolean;
    /** {@inheritDoc WidgetApi.requestCapabilities} */
    requestCapabilities(capabilities: Array<WidgetEventCapability | Capability>): Promise<void>;
    private requestCapabilitiesInternal;
    /** {@inheritDoc WidgetApi.hasCapabilities} */
    hasCapabilities(capabilities: Array<WidgetEventCapability | Capability>): boolean;
    /** {@inheritDoc WidgetApi.receiveSingleStateEvent} */
    receiveSingleStateEvent<T>(eventType: string, stateKey?: string): Promise<StateEvent<T> | undefined>;
    /** {@inheritDoc WidgetApi.receiveStateEvents} */
    receiveStateEvents<T>(eventType: string, { stateKey, roomIds, }?: {
        stateKey?: string;
        roomIds?: string[] | Symbols.AnyRoom;
    }): Promise<StateEvent<T>[]>;
    /** {@inheritDoc WidgetApi.observeStateEvents} */
    observeStateEvents<T>(eventType: string, { stateKey, roomIds, }?: {
        stateKey?: string;
        roomIds?: string[] | Symbols.AnyRoom;
    }): Observable<StateEvent<T>>;
    /** {@inheritDoc WidgetApi.sendStateEvent} */
    sendStateEvent<T>(eventType: string, content: T, { roomId, stateKey }?: {
        roomId?: string;
        stateKey?: string;
    }): Promise<ISendEventFromWidgetResponseData>;
    /** {@inheritDoc WidgetApi.sendDelayedStateEvent} */
    sendDelayedStateEvent<T>(eventType: string, content: T, delay: number, { roomId, stateKey }?: {
        roomId?: string;
        stateKey?: string;
    }): Promise<{
        delay_id: string;
    }>;
    /** {@inheritDoc WidgetApi.receiveRoomEvents} */
    receiveRoomEvents<T>(eventType: string, { messageType, roomIds, }?: {
        messageType?: string;
        roomIds?: string[] | Symbols.AnyRoom;
    }): Promise<Array<RoomEvent<T>>>;
    /** {@inheritDoc WidgetApi.observeRoomEvents} */
    observeRoomEvents<T>(eventType: string, { messageType, roomIds, }?: {
        messageType?: string;
        roomIds?: string[] | Symbols.AnyRoom;
    }): Observable<RoomEvent<T>>;
    /** {@inheritDoc WidgetApi.sendRoomEvent} */
    sendRoomEvent<T>(eventType: string, content: T, { roomId }?: {
        roomId?: string;
    }): Promise<RoomEvent<T>>;
    /** {@inheritDoc WidgetApi.sendDelayedRoomEvent} */
    sendDelayedRoomEvent<T>(eventType: string, content: T, delay: number, { roomId }?: {
        roomId?: string;
    }): Promise<{
        delay_id: string;
    }>;
    /** {@inheritDoc WidgetApi.updateDelayedEvent} */
    updateDelayedEvent(delayId: string, action: UpdateDelayedEventAction): Promise<void>;
    /** {@inheritDoc WidgetApi.readEventRelations} */
    readEventRelations(eventId: string, options?: {
        roomId?: string;
        limit?: number;
        from?: string;
        relationType?: string;
        eventType?: string;
        direction?: 'f' | 'b';
    }): Promise<{
        chunk: Array<RoomEvent | StateEvent>;
        nextToken?: string;
    }>;
    /** {@inheritDoc WidgetApi.sendToDeviceMessage} */
    sendToDeviceMessage<T>(eventType: string, encrypted: boolean, content: {
        [userId: string]: {
            [deviceId: string | '*']: T;
        };
    }): Promise<void>;
    /** {@inheritDoc WidgetApi.observeToDeviceMessages} */
    observeToDeviceMessages<T>(eventType: string): Observable<ToDeviceMessageEvent<T>>;
    /** {@inheritDoc WidgetApi.openModal} */
    openModal<T extends Record<string, unknown> = Record<string, unknown>, U extends IModalWidgetCreateData = IModalWidgetCreateData>(pathName: string, name: string, options?: {
        buttons?: IModalWidgetOpenRequestDataButton[];
        data?: U;
    }): Promise<T | undefined>;
    /** {@inheritDoc WidgetApi.setModalButtonEnabled} */
    setModalButtonEnabled(buttonId: ModalButtonID, isEnabled: boolean): Promise<void>;
    /** {@inheritDoc WidgetApi.observeModalButtons} */
    observeModalButtons(): Observable<ModalButtonID>;
    /** {@inheritDoc WidgetApi.closeModal} */
    closeModal<T extends IModalWidgetReturnData>(data?: T): Promise<void>;
    /** {@inheritdoc WidgetApi.navigateTo} */
    navigateTo(uri: string): Promise<void>;
    /** {@inheritdoc WidgetApi.requestOpenIDConnectToken} */
    requestOpenIDConnectToken(): Promise<IOpenIDCredentials>;
    private requestOpenIDConnectTokenInternal;
    /** {@inheritdoc WidgetApi.observeTurnServers} */
    observeTurnServers(): Observable<TurnServer>;
    /** {@inheritdoc WidgetApi.searchUserDirectory}  */
    searchUserDirectory(searchTerm: string, options?: {
        limit?: number | undefined;
    } | undefined): Promise<{
        results: Array<{
            userId: string;
            displayName?: string;
            avatarUrl?: string;
        }>;
    }>;
    /** {@inheritdoc WidgetApi.getMediaConfig}  */
    getMediaConfig(): Promise<IGetMediaConfigActionFromWidgetResponseData>;
    /** {@inheritdoc WidgetApi.uploadFile}  */
    uploadFile(file: XMLHttpRequestBodyInit): Promise<IUploadFileActionFromWidgetResponseData>;
    /** {@inheritdoc WidgetApi.downloadFile}  */
    downloadFile(contentUrl: string): Promise<IDownloadFileActionFromWidgetResponseData>;
}
