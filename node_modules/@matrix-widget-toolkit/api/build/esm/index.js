import { Symbols, WidgetEventCapability, EventDirection, WidgetApi, WidgetApiToWidgetAction, CurrentApiVersions, UnstableApiVersion, MatrixCapabilities } from 'matrix-widget-api';
import Joi from 'joi';
import { stringify, parse } from 'qs';
import { filter, fromEvent, firstValueFrom, map, first, throwError, from, mergeAll, concat, ReplaySubject, share } from 'rxjs';

/*
 * Copyright 2022 Nordeck IT + Consulting GmbH
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Generate a list of capabilities to access the timeline of other rooms.
 * If enabled, all previously or future capabilities will apply to _all_
 * selected rooms.
 * If `Symbols.AnyRoom` is passed, this is expanded to all joined
 * or invited rooms the client is able to see, current and future.
 *
 * @param roomIds - a list of room ids or `@link Symbols.AnyRoom`.
 * @returns the generated capabilities.
 */
function generateRoomTimelineCapabilities(roomIds) {
    if (roomIds === Symbols.AnyRoom) {
        return ['org.matrix.msc2762.timeline:*'];
    }
    if (Array.isArray(roomIds)) {
        return roomIds.map(function (id) { return "org.matrix.msc2762.timeline:".concat(id); });
    }
    return [];
}

/*
 * Copyright 2022 Nordeck IT + Consulting GmbH
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Generate a unique displayname of a user that is consistent across Matrix clients.
 *
 * @remarks The algorithm is based on https://spec.matrix.org/v1.1/client-server-api/#calculating-the-display-name-for-a-user
 *
 * @param member - the member to generate a name for.
 * @param allRoomMembers - a list of all members of the same room.
 * @returns the displayname that is unique in given the set of all room members.
 */
function getRoomMemberDisplayName(member, allRoomMembers) {
    if (allRoomMembers === void 0) { allRoomMembers = []; }
    // If the m.room.member state event has no displayname field, or if that field
    // has a null value, use the raw user id as the display name.
    if (typeof member.content.displayname !== 'string') {
        return member.state_key;
    }
    // If the m.room.member event has a displayname which is unique among members of
    // the room with membership: join or membership: invite, ...
    var hasDuplicateDisplayName = allRoomMembers.some(function (m) {
        // same room
        return m.room_id === member.room_id &&
            // not the own event
            m.state_key !== member.state_key &&
            // only join or invite state
            ['join', 'invite'].includes(m.content.membership) &&
            // same displayname
            m.content.displayname === member.content.displayname;
    });
    if (!hasDuplicateDisplayName) {
        // ... use the given displayname as the user-visible display name.
        return member.content.displayname;
    }
    else {
        // The m.room.member event has a non-unique displayname. This should be
        // disambiguated using the user id, for example “display name (@id:homeserver.org)”.
        return "".concat(member.content.displayname, " (").concat(member.state_key, ")");
    }
}

/*
 * Copyright 2022 Nordeck IT + Consulting GmbH
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __assign$2 = (undefined && undefined.__assign) || function () {
    __assign$2 = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign$2.apply(this, arguments);
};
/**
 * Check if the given event is a {@link StateEvent}.
 *
 * @param event - An event that is either a {@link RoomEvent} or a {@link StateEvent}.
 * @returns True, if the event is a {@link StateEvent}.
 */
function isStateEvent(event) {
    return 'state_key' in event && typeof event.state_key === 'string';
}
/**
 * Check if the given event is a {@link RoomEvent}.
 *
 * @param event - An event that is either a {@link RoomEvent} or a {@link StateEvent}.
 * @returns True, if the event is a {@link RoomEvent}.
 */
function isRoomEvent(event) {
    return !('state_key' in event);
}
/**
 * Check if the given value is a valid {@link RoomEvent}.
 *
 * @param event - The value to check
 * @returns true if value is a valid room event, else false.
 */
// Allow any here, so that the validation works for every event
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function isValidRoomEvent(event) {
    return roomEventSchema.validate(event).error === undefined;
}
/**
 * Check if the given value is a valid {@link StateEvent}.
 *
 * @param event - The value to check
 * @returns true if value is a valid state event, else false.
 */
// Allow any here, so that the validation works for every event
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function isValidStateEvent(event) {
    return stateEventSchema.validate(event).error === undefined;
}
/**
 * Check if the given value is a valid {@link ToDeviceMessageEvent}.
 *
 * @param event - The value to check
 * @returns true if value is a valid to device message, else false.
 */
function isValidToDeviceMessageEvent(event) {
    return toDeviceMessageSchema.validate(event).error === undefined;
}
/**
 * Base properties to validate for all events.
 */
var eventSchemaProps = {
    type: Joi.string().required(),
    // Do roughly check against the format
    // https://spec.matrix.org/v1.13/appendices/#common-identifier-format
    sender: Joi.string().pattern(new RegExp('^@[^\\s:]*:\\S*$')).required(),
    room_id: Joi.string().pattern(new RegExp('^![^:]*:\\S*')).required(),
    content: Joi.object().required(),
};
var roomEventSchema = Joi.object(__assign$2(__assign$2({}, eventSchemaProps), { event_id: Joi.string().pattern(new RegExp('^\\$.*')).required(), origin_server_ts: Joi.date().timestamp('javascript').required() })).unknown();
var stateEventSchema = Joi.object(__assign$2(__assign$2({}, eventSchemaProps), { event_id: Joi.string().pattern(new RegExp('^\\$.*')), origin_server_ts: Joi.date().timestamp('javascript'), state_key: Joi.string().allow('').required() })).unknown();
var toDeviceMessageSchema = Joi.object({
    type: Joi.string().required(),
    sender: Joi.string().required(),
    encrypted: Joi.boolean().required(),
    content: Joi.object().required(),
}).unknown();

/*
 * Copyright 2022 Nordeck IT + Consulting GmbH
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __awaiter$4 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator$4 = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
/**
 * The capability that needs to be requested in order to navigate to another room.
 */
var WIDGET_CAPABILITY_NAVIGATE = 'org.matrix.msc2931.navigate';
/**
 * Navigate the client to another matrix room.
 *
 * @remarks This requires the {@link WIDGET_CAPABILITY_NAVIGATE} capability.
 *
 * @param widgetApi - the {@link WidgetApi} instance.
 * @param roomId - the room ID.
 * @param opts - {@link NavigateToRoomOptions}
 */
function navigateToRoom(widgetApi_1, roomId_1) {
    return __awaiter$4(this, arguments, void 0, function (widgetApi, roomId, opts) {
        var _a, via, params, url;
        if (opts === void 0) { opts = {}; }
        return __generator$4(this, function (_b) {
            switch (_b.label) {
                case 0:
                    _a = opts.via, via = _a === void 0 ? [] : _a;
                    params = stringify({ via: via }, { addQueryPrefix: true, arrayFormat: 'repeat' });
                    url = "https://matrix.to/#/".concat(encodeURIComponent(roomId)).concat(params);
                    return [4 /*yield*/, widgetApi.navigateTo(url)];
                case 1:
                    _b.sent();
                    return [2 /*return*/];
            }
        });
    });
}

/*
 * Copyright 2022 Nordeck IT + Consulting GmbH
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Compares two room events by their origin server timestamp.
 *
 * @param a - A room event
 * @param b - A room event
 * @returns Either zero if the timestamp is equal, \>0 if a is newer, or \<0 if
 *          b is newer.
 */
function compareOriginServerTS(a, b) {
    return a.origin_server_ts - b.origin_server_ts;
}

/*
 * Copyright 2022 Nordeck IT + Consulting GmbH
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * The name of the power levels state event.
 */
var STATE_EVENT_POWER_LEVELS = 'm.room.power_levels';
function isNumberOrUndefined(value) {
    return value === undefined || typeof value === 'number';
}
function isStringToNumberMapOrUndefined(value) {
    return (value === undefined ||
        (value !== null &&
            typeof value === 'object' &&
            Object.entries(value).every(function (_a) {
                var k = _a[0], v = _a[1];
                return typeof k === 'string' && typeof v === 'number';
            })));
}
/**
 * Validates that `event` is has a valid structure for a
 * {@link PowerLevelsStateEvent}.
 * @param event - The event to validate.
 * @returns True, if the event is valid.
 */
function isValidPowerLevelStateEvent(event) {
    if (event.type !== STATE_EVENT_POWER_LEVELS ||
        typeof event.content !== 'object') {
        return false;
    }
    var content = event.content;
    if (!isStringToNumberMapOrUndefined(content.events)) {
        return false;
    }
    if (!isNumberOrUndefined(content.state_default)) {
        return false;
    }
    if (!isNumberOrUndefined(content.events_default)) {
        return false;
    }
    if (!isStringToNumberMapOrUndefined(content.users)) {
        return false;
    }
    if (!isNumberOrUndefined(content.users_default)) {
        return false;
    }
    if (!isNumberOrUndefined(content.ban)) {
        return false;
    }
    if (!isNumberOrUndefined(content.invite)) {
        return false;
    }
    if (!isNumberOrUndefined(content.kick)) {
        return false;
    }
    if (!isNumberOrUndefined(content.redact)) {
        return false;
    }
    return true;
}
/**
 * Check if a user has the power to send a specific room event.
 *
 * @param powerLevelStateEvent - the content of the `m.room.power_levels` event
 * @param userId - the id of the user
 * @param eventType - the type of room event
 * @returns if true, the user has the power
 */
function hasRoomEventPower(powerLevelStateEvent, userId, eventType) {
    if (!powerLevelStateEvent) {
        // See https://github.com/matrix-org/matrix-spec/blob/203b9756f52adfc2a3b63d664f18cdbf9f8bf126/data/event-schemas/schema/m.room.power_levels.yaml#L36-L43
        return true;
    }
    var userLevel = calculateUserPowerLevel(powerLevelStateEvent, userId);
    var eventLevel = calculateRoomEventPowerLevel(powerLevelStateEvent, eventType);
    return userLevel >= eventLevel;
}
/**
 * Check if a user has the power to send a specific state event.
 *
 * @param powerLevelStateEvent - the content of the `m.room.power_levels` event
 * @param userId - the id of the user
 * @param eventType - the type of state event
 * @returns if true, the user has the power
 */
function hasStateEventPower(powerLevelStateEvent, userId, eventType) {
    if (!powerLevelStateEvent) {
        // See https://github.com/matrix-org/matrix-spec/blob/203b9756f52adfc2a3b63d664f18cdbf9f8bf126/data/event-schemas/schema/m.room.power_levels.yaml#L36-L43
        return true;
    }
    var userLevel = calculateUserPowerLevel(powerLevelStateEvent, userId);
    var eventLevel = calculateStateEventPowerLevel(powerLevelStateEvent, eventType);
    return userLevel >= eventLevel;
}
/**
 * Check if a user has the power to perform a specific action.
 *
 * Supported actions:
 *   * invite: Invite a new user into the room
 *   * kick: Kick a user from the room
 *   * ban: Ban a user from the room
 *   * redact: Redact a message from another user
 *
 * @param powerLevelStateEvent - the content of the `m.room.power_levels` event
 * @param userId - the id of the user
 * @param action - the action
 * @returns if true, the user has the power
 */
function hasActionPower(powerLevelStateEvent, userId, action) {
    if (!powerLevelStateEvent) {
        // See https://github.com/matrix-org/matrix-spec/blob/203b9756f52adfc2a3b63d664f18cdbf9f8bf126/data/event-schemas/schema/m.room.power_levels.yaml#L36-L43
        return true;
    }
    var userLevel = calculateUserPowerLevel(powerLevelStateEvent, userId);
    var eventLevel = calculateActionPowerLevel(powerLevelStateEvent, action);
    return userLevel >= eventLevel;
}
/**
 * Calculate the power level of the user based on a `m.room.power_levels` event.
 *
 * @param powerLevelStateEvent - the content of the `m.room.power_levels` event.
 * @param userId - the ID of the user.
 * @returns the power level of the user.
 */
function calculateUserPowerLevel(powerLevelStateEvent, userId) {
    var _a, _b, _c;
    // See https://github.com/matrix-org/matrix-spec/blob/203b9756f52adfc2a3b63d664f18cdbf9f8bf126/data/event-schemas/schema/m.room.power_levels.yaml#L8-L12
    return ((_c = (_b = (userId ? (_a = powerLevelStateEvent.users) === null || _a === void 0 ? void 0 : _a[userId] : undefined)) !== null && _b !== void 0 ? _b : powerLevelStateEvent.users_default) !== null && _c !== void 0 ? _c : 0);
}
/**
 * Calculate the power level that a user needs send a specific room event.
 *
 * @param powerLevelStateEvent - the content of the `m.room.power_levels` event
 * @param eventType - the type of room event
 * @returns the power level that is needed
 */
function calculateRoomEventPowerLevel(powerLevelStateEvent, eventType) {
    var _a, _b, _c;
    // See https://github.com/matrix-org/matrix-spec/blob/203b9756f52adfc2a3b63d664f18cdbf9f8bf126/data/event-schemas/schema/m.room.power_levels.yaml#L14-L19
    return ((_c = (_b = (_a = powerLevelStateEvent.events) === null || _a === void 0 ? void 0 : _a[eventType]) !== null && _b !== void 0 ? _b : powerLevelStateEvent.events_default) !== null && _c !== void 0 ? _c : 0);
}
/**
 * Calculate the power level that a user needs send a specific state event.
 *
 * @param powerLevelStateEvent - the content of the `m.room.power_levels` event
 * @param eventType - the type of state event
 * @returns the power level that is needed
 */
function calculateStateEventPowerLevel(powerLevelStateEvent, eventType) {
    var _a, _b, _c;
    // See https://github.com/matrix-org/matrix-spec/blob/203b9756f52adfc2a3b63d664f18cdbf9f8bf126/data/event-schemas/schema/m.room.power_levels.yaml#L14-L19
    return ((_c = (_b = (_a = powerLevelStateEvent.events) === null || _a === void 0 ? void 0 : _a[eventType]) !== null && _b !== void 0 ? _b : powerLevelStateEvent.state_default) !== null && _c !== void 0 ? _c : 50);
}
/**
 * Calculate the power level that a user needs to perform an action.
 *
 * Supported actions:
 *   * invite: Invite a new user into the room
 *   * kick: Kick a user from the room
 *   * ban: Ban a user from the room
 *   * redact: Redact a message from another user
 *
 * @param powerLevelStateEvent - the content of the `m.room.power_levels` event
 * @param action - the action
 * @returns the power level that is needed
 */
function calculateActionPowerLevel(powerLevelStateEvent, action) {
    var _a, _b;
    // See https://github.com/matrix-org/matrix-spec/blob/203b9756f52adfc2a3b63d664f18cdbf9f8bf126/data/event-schemas/schema/m.room.power_levels.yaml#L27-L32
    if (action === 'invite') {
        return (_a = powerLevelStateEvent === null || powerLevelStateEvent === void 0 ? void 0 : powerLevelStateEvent[action]) !== null && _a !== void 0 ? _a : 0;
    }
    return (_b = powerLevelStateEvent === null || powerLevelStateEvent === void 0 ? void 0 : powerLevelStateEvent[action]) !== null && _b !== void 0 ? _b : 50;
}

/*
 * Copyright 2022 Nordeck IT + Consulting GmbH
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __awaiter$3 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator$3 = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
/**
 * The name of the redaction room event.
 */
var ROOM_EVENT_REDACTION = 'm.room.redaction';
/**
 * Check whether the format of a redaction event is valid.
 * @param event - The event to check.
 * @returns True if the event format is valid, otherwise false.
 */
function isValidRedactionEvent(event) {
    if (event.type === ROOM_EVENT_REDACTION &&
        typeof event.redacts === 'string') {
        return true;
    }
    return false;
}
/**
 * Redacts an event in the current room.
 * @param widgetApi - An instance of the widget API.
 * @param eventId - The id of the event to redact.
 * @returns The redaction event that was send to the room.
 */
function redactEvent(widgetApi, eventId) {
    return __awaiter$3(this, void 0, void 0, function () {
        var result;
        return __generator$3(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, widgetApi.sendRoomEvent(ROOM_EVENT_REDACTION, { redacts: eventId })];
                case 1:
                    result = _a.sent();
                    // The redaction event is special and needs to be casted, as the widget
                    // toolkit assumes that the content of an event is returned as we send it.
                    // However for redactions the content is copied directly into the event to
                    // make it available without decrypting the content.
                    return [2 /*return*/, result];
            }
        });
    });
}
/**
 * Observes redaction events in the current room.
 * @param widgetApi - An instance of the widget API.
 * @returns An observable of validated redaction events.
 */
function observeRedactionEvents(widgetApi) {
    return widgetApi
        .observeRoomEvents(ROOM_EVENT_REDACTION)
        .pipe(filter(isValidRedactionEvent));
}

/*
 * Copyright 2022 Nordeck IT + Consulting GmbH
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Get the original event id, or the event id of the current event if it
 * doesn't relates to another event.
 * @param event - The room event.
 * @returns The event id of the original event, or the current event id.
 */
function getOriginalEventId(event) {
    var _a, _b, _c;
    var newContentRelatesTo = event.content;
    if (((_a = newContentRelatesTo['m.relates_to']) === null || _a === void 0 ? void 0 : _a.rel_type) === 'm.replace') {
        return (_c = (_b = newContentRelatesTo['m.relates_to']) === null || _b === void 0 ? void 0 : _b.event_id) !== null && _c !== void 0 ? _c : event.event_id;
    }
    return event.event_id;
}
/**
 * Get the content of the event, independent from whether it contains the
 * content directly or contains a "m.new_content" key.
 * @param event - The room event.
 * @returns Only the content of the room event.
 */
function getContent(event) {
    var _a;
    var newContentRelatesTo = event.content;
    return (_a = newContentRelatesTo['m.new_content']) !== null && _a !== void 0 ? _a : event.content;
}
/**
 * Validates that `event` has a valid structure for a
 * {@link EventWithRelatesTo}.
 * @param event - The event to validate.
 * @returns True, if the event is valid.
 */
function isValidEventWithRelatesTo(event) {
    if (!event.content || typeof event.content !== 'object') {
        return false;
    }
    var relatedEvent = event;
    if (!relatedEvent.content['m.relates_to'] ||
        typeof relatedEvent.content['m.relates_to'] !== 'object') {
        return false;
    }
    if (typeof relatedEvent.content['m.relates_to'].rel_type !== 'string' ||
        typeof relatedEvent.content['m.relates_to'].event_id !== 'string') {
        return false;
    }
    return true;
}

/*
 * Copyright 2022 Nordeck IT + Consulting GmbH
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * The name of the room member state event.
 */
var STATE_EVENT_ROOM_MEMBER = 'm.room.member';
function isStringUndefinedOrNull(value) {
    return value === undefined || value === null || typeof value === 'string';
}
/**
 * Validates that `event` is has a valid structure for a
 * {@link RoomMemberStateEventContent}.
 * @param event - The event to validate.
 * @returns True, if the event is valid.
 */
function isValidRoomMemberStateEvent(event) {
    if (event.type !== STATE_EVENT_ROOM_MEMBER ||
        typeof event.content !== 'object') {
        return false;
    }
    var content = event.content;
    if (typeof content.membership !== 'string') {
        return false;
    }
    if (!isStringUndefinedOrNull(content.displayname)) {
        return false;
    }
    // the avatar_url shouldn't be null, but some implementations
    // set it as a valid value
    if (!isStringUndefinedOrNull(content.avatar_url)) {
        return false;
    }
    return true;
}

/*
 * Copyright 2022 Nordeck IT + Consulting GmbH
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __assign$1 = (undefined && undefined.__assign) || function () {
    __assign$1 = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign$1.apply(this, arguments);
};
/**
 * Extract the parameters used to initialize the widget API from the current
 * `window.location`.
 * @returns The parameters required for initializing the widget API.
 */
function extractWidgetApiParameters() {
    var query = parse(window.location.search, { ignoreQueryPrefix: true });
    // If either parentUrl or widgetId is missing, we have no element context and
    // want to inform the user that the widget only works inside of element.
    if (typeof query.parentUrl !== 'string') {
        throw Error('Missing parameter "parentUrl"');
    }
    var clientOrigin = new URL(query.parentUrl).origin;
    if (typeof query.widgetId !== 'string') {
        throw Error('Missing parameter "widgetId"');
    }
    var widgetId = query.widgetId;
    return { widgetId: widgetId, clientOrigin: clientOrigin };
}
/**
 * Extract the widget parameters from the current `window.location`.
 * @returns The all unprocessed raw widget parameters.
 */
function extractRawWidgetParameters() {
    var hash = window.location.hash.substring(window.location.hash.indexOf('?') + 1);
    var params = __assign$1(__assign$1({}, parse(window.location.search, { ignoreQueryPrefix: true })), parse(hash));
    return Object.fromEntries(Object.entries(params).filter(
    // For now only use simple values, don't allow them to be specified more
    // than once.
    function (e) { return typeof e[1] === 'string'; }));
}
/**
 * Extract the widget parameters from the current `window.location`.
 * @returns The widget parameters.
 */
function extractWidgetParameters() {
    var params = extractRawWidgetParameters();
    // This is a hack to detect whether we are in a mobile client that supports widgets,
    // but not the widget API. Mobile clients are not passing the parameters required for
    // the widget API (like widgetId), but are passing the replaced placeholder values for
    // the widget parameters.
    var roomId = params['matrix_room_id'];
    var isOpenedByClient = typeof roomId === 'string' && roomId !== '$matrix_room_id';
    return {
        userId: params['matrix_user_id'],
        displayName: params['matrix_display_name'],
        avatarUrl: params['matrix_avatar_url'],
        roomId: roomId,
        theme: params['theme'],
        clientId: params['matrix_client_id'],
        clientLanguage: params['matrix_client_language'],
        baseUrl: params['matrix_base_url'],
        deviceId: params['matrix_device_id'],
        isOpenedByClient: isOpenedByClient,
    };
}
/**
 * Parse a widget id into the individual fields.
 * @param widgetId - The widget id to parse.
 * @returns The individual fields encoded inside a widget id.
 */
function parseWidgetId(widgetId) {
    // TODO: Is this whole parsing still working for user widgets?
    var mainWidgetId = decodeURIComponent(widgetId).replace(/^modal_/, '');
    var roomId = mainWidgetId.indexOf('_')
        ? decodeURIComponent(mainWidgetId.split('_')[0])
        : undefined;
    var creator = (mainWidgetId.match(/_/g) || []).length > 1
        ? decodeURIComponent(mainWidgetId.split('_')[1])
        : undefined;
    var isModal = decodeURIComponent(widgetId).startsWith('modal_');
    return {
        mainWidgetId: mainWidgetId,
        roomId: roomId,
        creator: creator,
        isModal: isModal,
    };
}

/*
 * Copyright 2022 Nordeck IT + Consulting GmbH
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter$2 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator$2 = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
/**
 * Checks whether the necessary widget parameters were provided to the widget.
 *
 * @param widgetApi - The widget api to read the parameters from
 * @returns True, if all parameters were provided.
 */
function hasWidgetParameters(widgetApi) {
    return (typeof widgetApi.widgetParameters.userId === 'string' &&
        typeof widgetApi.widgetParameters.displayName === 'string' &&
        typeof widgetApi.widgetParameters.avatarUrl === 'string' &&
        typeof widgetApi.widgetParameters.roomId === 'string' &&
        typeof widgetApi.widgetParameters.theme === 'string' &&
        typeof widgetApi.widgetParameters.clientId === 'string' &&
        typeof widgetApi.widgetParameters.clientLanguage === 'string' &&
        typeof widgetApi.widgetParameters.baseUrl === 'string');
}
/**
 * Generate a registration URL for the widget based on the current URL and
 * include all widget parameters (and their placeholders).
 * @param options - Options for generating the URL.
 *                  Use `pathName` to include an optional sub path in the URL.
 *                  Use `includeParameters` to append the widget parameters to
 *                  the URL, defaults to `true`.
 * @returns The generated URL.
 */
function generateWidgetRegistrationUrl(options) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    if (options === void 0) { options = {}; }
    var pathName = options.pathName, _k = options.includeParameters, includeParameters = _k === void 0 ? true : _k, widgetParameters = options.widgetParameters;
    // don't forward widgetId and parentUrl as they will be generated by the client
    // eslint-disable-next-line
    var _l = extractRawWidgetParameters(); _l.widgetId; _l.parentUrl; var rawWidgetParameters = __rest(_l, ["widgetId", "parentUrl"]);
    var parameters = Object.entries(__assign(__assign({}, rawWidgetParameters), { theme: (_a = widgetParameters === null || widgetParameters === void 0 ? void 0 : widgetParameters.theme) !== null && _a !== void 0 ? _a : '$org.matrix.msc2873.client_theme', matrix_user_id: (_b = widgetParameters === null || widgetParameters === void 0 ? void 0 : widgetParameters.userId) !== null && _b !== void 0 ? _b : '$matrix_user_id', matrix_display_name: (_c = widgetParameters === null || widgetParameters === void 0 ? void 0 : widgetParameters.displayName) !== null && _c !== void 0 ? _c : '$matrix_display_name', matrix_avatar_url: (_d = widgetParameters === null || widgetParameters === void 0 ? void 0 : widgetParameters.avatarUrl) !== null && _d !== void 0 ? _d : '$matrix_avatar_url', matrix_room_id: (_e = widgetParameters === null || widgetParameters === void 0 ? void 0 : widgetParameters.roomId) !== null && _e !== void 0 ? _e : '$matrix_room_id', matrix_client_id: (_f = widgetParameters === null || widgetParameters === void 0 ? void 0 : widgetParameters.clientId) !== null && _f !== void 0 ? _f : '$org.matrix.msc2873.client_id', matrix_client_language: (_g = widgetParameters === null || widgetParameters === void 0 ? void 0 : widgetParameters.clientLanguage) !== null && _g !== void 0 ? _g : '$org.matrix.msc2873.client_language', matrix_device_id: (_h = widgetParameters === null || widgetParameters === void 0 ? void 0 : widgetParameters.deviceId) !== null && _h !== void 0 ? _h : '$org.matrix.msc3819.matrix_device_id', matrix_base_url: (_j = widgetParameters === null || widgetParameters === void 0 ? void 0 : widgetParameters.baseUrl) !== null && _j !== void 0 ? _j : '$org.matrix.msc4039.matrix_base_url' }))
        .map(function (_a) {
        var k = _a[0], v = _a[1];
        return "".concat(k, "=").concat(v);
    })
        .join('&');
    var url = new URL(window.location.href);
    if (pathName) {
        url.pathname = pathName;
    }
    else {
        // ensure trailing '/'
        url.pathname = url.pathname.replace(/\/?$/, '/');
    }
    url.search = '';
    url.hash = includeParameters ? "#/?".concat(parameters) : '';
    return url.toString();
}
var STATE_EVENT_WIDGETS = 'im.vector.modular.widgets';
/**
 * Repair/configure the registration of the current widget.
 * This steps make sure to include all the required widget parameters in the
 * URL. Support setting a widget name and additional parameters.
 *
 * @param widgetApi - The widget api of the current widget.
 * @param registration - Optional configuration options for the widget
 *                       registration, like the display name of the widget.
 */
function repairWidgetRegistration(widgetApi_1) {
    return __awaiter$2(this, arguments, void 0, function (widgetApi, registration) {
        var readResult, url, name, type, data;
        if (registration === void 0) { registration = {}; }
        return __generator$2(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, widgetApi.requestCapabilities([
                        WidgetEventCapability.forStateEvent(EventDirection.Send, STATE_EVENT_WIDGETS, widgetApi.widgetId),
                        WidgetEventCapability.forStateEvent(EventDirection.Receive, STATE_EVENT_WIDGETS, widgetApi.widgetId),
                    ])];
                case 1:
                    _a.sent();
                    return [4 /*yield*/, widgetApi.receiveSingleStateEvent(STATE_EVENT_WIDGETS, widgetApi.widgetId)];
                case 2:
                    readResult = _a.sent();
                    if (!readResult) {
                        throw new Error("Error while repairing registration, can't find existing registration.");
                    }
                    url = generateWidgetRegistrationUrl();
                    name = registration.name &&
                        (!readResult.content.name ||
                            readResult.content.name === 'Custom Widget' ||
                            readResult.content.name === 'Custom')
                        ? registration.name
                        : readResult.content.name;
                    type = registration.type &&
                        (!readResult.content.type || readResult.content.type === 'm.custom')
                        ? registration.type
                        : readResult.content.type;
                    data = registration.data
                        ? __assign(__assign({}, readResult.content.data), registration.data) : readResult.content.data;
                    // This is a workaround because changing the widget config is breaking the
                    // widget API communication. However we need to fail in case the power level
                    // for this change is missing. As the error happens quite fast, we just wait
                    // a moment and then consider the operation as succeeded.
                    return [4 /*yield*/, Promise.race([
                            widgetApi.sendStateEvent(STATE_EVENT_WIDGETS, __assign(__assign({}, readResult.content), { url: url.toString(), name: name, type: type, data: data }), { stateKey: widgetApi.widgetId }),
                            new Promise(function (resolve) { return setTimeout(resolve, 1000); }),
                        ])];
                case 3:
                    // This is a workaround because changing the widget config is breaking the
                    // widget API communication. However we need to fail in case the power level
                    // for this change is missing. As the error happens quite fast, we just wait
                    // a moment and then consider the operation as succeeded.
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    });
}

/*
 * Copyright 2022 Nordeck IT + Consulting GmbH
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Enumeration of widget parameters that can be checked if they are available upon registration.
 */
var WidgetParameter;
(function (WidgetParameter) {
    WidgetParameter["UserId"] = "userId";
    WidgetParameter["DisplayName"] = "displayName";
    WidgetParameter["AvatarUrl"] = "avatarUrl";
    WidgetParameter["RoomId"] = "roomId";
    WidgetParameter["Theme"] = "theme";
    WidgetParameter["ClientId"] = "clientId";
    WidgetParameter["ClientLanguage"] = "clientLanguage";
    WidgetParameter["DeviceId"] = "deviceId";
    WidgetParameter["BaseUrl"] = "baseUrl";
})(WidgetParameter || (WidgetParameter = {}));

/*
 * Copyright 2022 Nordeck IT + Consulting GmbH
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __awaiter$1 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator$1 = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
function convertToRawCapabilities(rawCapabilities) {
    return rawCapabilities.map(function (c) { return (typeof c === 'string' ? c : c.raw); });
}
function isDefined(arg) {
    return arg !== null && arg !== undefined;
}
function unique(items) {
    return Array.from(new Set(items));
}
function subtractSet(as, bs) {
    var result = new Set(as);
    bs.forEach(function (v) { return result.delete(v); });
    return result;
}
function isInRoom(matrixEvent, currentRoomId, roomIds) {
    if (!roomIds) {
        return matrixEvent.room_id === currentRoomId;
    }
    if (typeof roomIds === 'string') {
        if (roomIds !== Symbols.AnyRoom) {
            throw Error("Unknown room id symbol: ".concat(roomIds));
        }
        return true;
    }
    return roomIds.includes(matrixEvent.room_id);
}
/**
 * Create a state event from the arguments.
 *
 * @returns A state event with current timestamp origin_server_ts.
 */
function makeEventFromSendStateEventResult(type, stateKey, content, sender, sendResult) {
    if (sendResult.event_id === undefined) {
        throw new Error('Send state event did not return an event ID');
    }
    return {
        content: content,
        event_id: sendResult.event_id,
        origin_server_ts: Date.now(),
        room_id: sendResult.room_id,
        sender: sender,
        state_key: stateKey,
        type: type,
    };
}
/**
 * Send a state event and resolve to a "virtual" state event.
 *
 * @returns Promise, that resolves to a state event with current timestamp origin_server_ts.
 */
function sendStateEventWithEventResult(widgetApi, type, stateKey, content) {
    return __awaiter$1(this, void 0, void 0, function () {
        var response;
        return __generator$1(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (widgetApi.widgetParameters.userId === undefined) {
                        throw new Error('Own user ID is undefined');
                    }
                    return [4 /*yield*/, widgetApi.sendStateEvent(type, content, { stateKey: stateKey })];
                case 1:
                    response = _a.sent();
                    return [2 /*return*/, makeEventFromSendStateEventResult(type, stateKey, content, widgetApi.widgetParameters.userId, response)];
            }
        });
    });
}

/*
 * Copyright 2022 Nordeck IT + Consulting GmbH
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
/**
 * Implementation of the API from the widget to the client.
 *
 * @remarks Widget API is specified here:
 * https://docs.google.com/document/d/1uPF7XWY_dXTKVKV7jZQ2KmsI19wn9-kFRgQ1tFQP7wQ/edit#heading=h.9rn9lt6ctkgi
 */
var WidgetApiImpl = /** @class */ (function () {
    function WidgetApiImpl(
    /**
     * Provide access to the underlying widget API from `matrix-widget-sdk`.
     *
     * @remarks Normally there is no need to use it, however if features are
     *          missing from `WidgetApi` it can be handy to work with the
     *          original API.
     */
    matrixWidgetApi, 
    /** {@inheritDoc WidgetApi.widgetId} */
    widgetId, 
    /** {@inheritDoc WidgetApi.widgetParameters} */
    widgetParameters, _a) {
        var _b = _a === void 0 ? {} : _a, _c = _b.capabilities, capabilities = _c === void 0 ? [] : _c, _d = _b.supportStandalone, supportStandalone = _d === void 0 ? false : _d;
        var _this = this;
        this.matrixWidgetApi = matrixWidgetApi;
        this.widgetId = widgetId;
        this.widgetParameters = widgetParameters;
        // Disable the update_state API that is not implemented.
        this.matrixWidgetApi.on("action:".concat(WidgetApiToWidgetAction.SupportedApiVersions), function (event) {
            event.preventDefault();
            var supportedVersions = CurrentApiVersions.filter(function (apiVersion) {
                return apiVersion !== UnstableApiVersion.MSC2762_UPDATE_STATE;
            });
            matrixWidgetApi.transport.reply(event.detail, {
                supported_versions: supportedVersions,
            });
        });
        this.events$ = fromEvent(this.matrixWidgetApi, "action:".concat(WidgetApiToWidgetAction.SendEvent), function (event) {
            event.preventDefault();
            try {
                _this.matrixWidgetApi.transport.reply(event.detail, {});
            }
            catch (_a) {
                // Ignore errors while replying
            }
            return event;
        }).pipe(share());
        this.toDeviceMessages$ = fromEvent(this.matrixWidgetApi, 'action:send_to_device', function (event) {
            event.preventDefault();
            try {
                matrixWidgetApi.transport.reply(event.detail, {});
            }
            catch (_a) {
                // Ignore errors while replying
            }
            return event;
        })
            .pipe(filter(function (event) { return isValidToDeviceMessageEvent(event.detail.data); }))
            .pipe(share());
        this.initialCapabilities = __spreadArray(__spreadArray([], capabilities, true), (supportStandalone ? [] : [MatrixCapabilities.RequiresClient]), true);
    }
    /**
     * Initialize a new widget API instance and wait till it is ready.
     * There should only be one instance of the widget API. The widget API should
     * be created as early as possible when starting the application. This is
     * required to match the timing of the API connection establishment with the
     * client, especially in Safari. Therefore it is recommended to create it
     * inside the entrypoint, before initializing rendering engines like react.
     *
     * @param param0 - {@link WidgetApiOptions}
     *
     * @returns A widget API instance ready to use.
     */
    WidgetApiImpl.create = function () {
        return __awaiter(this, arguments, void 0, function (_a) {
            var _b, clientOrigin, widgetId, widgetParameters, matrixWidgetApi, widgetApi;
            var _c = _a === void 0 ? {} : _a, _d = _c.capabilities, capabilities = _d === void 0 ? [] : _d, _e = _c.supportStandalone, supportStandalone = _e === void 0 ? false : _e;
            return __generator(this, function (_f) {
                switch (_f.label) {
                    case 0:
                        _b = extractWidgetApiParameters(), clientOrigin = _b.clientOrigin, widgetId = _b.widgetId;
                        widgetParameters = extractWidgetParameters();
                        matrixWidgetApi = new WidgetApi(widgetId, clientOrigin);
                        widgetApi = new WidgetApiImpl(matrixWidgetApi, widgetId, widgetParameters, { capabilities: capabilities, supportStandalone: supportStandalone });
                        return [4 /*yield*/, widgetApi.initialize()];
                    case 1:
                        _f.sent();
                        return [2 /*return*/, widgetApi];
                }
            });
        });
    };
    /**
     * Initialize the widget API and wait till a connection with the client is
     * fully established.
     *
     * Waits till the user has approved the initial set of capabilities. The
     * method doesn't fail if the user doesn't approve all of them. It is
     * required to check manually afterwards.
     * In case of modal widgets it waits till the `widgetConfig` is received.
     *
     * @remarks Should only be called once during startup.
     */
    WidgetApiImpl.prototype.initialize = function () {
        return __awaiter(this, void 0, void 0, function () {
            var ready, isModal, configReady, rawCapabilities;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        ready = new Promise(function (resolve) {
                            _this.matrixWidgetApi.once('ready', function () { return resolve(); });
                        });
                        isModal = parseWidgetId(this.widgetId).isModal;
                        configReady = isModal
                            ? (function () { return __awaiter(_this, void 0, void 0, function () {
                                var widgetConfig$, _a;
                                var _this = this;
                                return __generator(this, function (_b) {
                                    switch (_b.label) {
                                        case 0:
                                            widgetConfig$ = fromEvent(this.matrixWidgetApi, "action:".concat(WidgetApiToWidgetAction.WidgetConfig), function (ev) {
                                                ev.preventDefault();
                                                _this.matrixWidgetApi.transport.reply(ev.detail, {});
                                                return ev.detail.data;
                                            });
                                            _a = this;
                                            return [4 /*yield*/, firstValueFrom(widgetConfig$)];
                                        case 1:
                                            _a.widgetConfig = _b.sent();
                                            return [2 /*return*/];
                                    }
                                });
                            }); })()
                            : undefined;
                        rawCapabilities = unique(convertToRawCapabilities(this.initialCapabilities));
                        this.matrixWidgetApi.requestCapabilities(rawCapabilities);
                        this.matrixWidgetApi.start();
                        return [4 /*yield*/, ready];
                    case 1:
                        _a.sent();
                        if (!configReady) return [3 /*break*/, 3];
                        return [4 /*yield*/, configReady];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    /** {@inheritDoc WidgetApi.getWidgetConfig} */
    WidgetApiImpl.prototype.getWidgetConfig = function () {
        return this.widgetConfig;
    };
    /** {@inheritDoc WidgetApi.rerequestInitialCapabilities} */
    WidgetApiImpl.prototype.rerequestInitialCapabilities = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.requestCapabilities(this.initialCapabilities)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /** {@inheritDoc WidgetApi.hasInitialCapabilities} */
    WidgetApiImpl.prototype.hasInitialCapabilities = function () {
        return this.hasCapabilities(this.initialCapabilities);
    };
    /** {@inheritDoc WidgetApi.requestCapabilities} */
    WidgetApiImpl.prototype.requestCapabilities = function (capabilities) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!this.outstandingCapabilitiesRequest) return [3 /*break*/, 4];
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.outstandingCapabilitiesRequest];
                    case 2:
                        _b.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        _b.sent();
                        return [3 /*break*/, 4];
                    case 4:
                        _b.trys.push([4, , 6, 7]);
                        this.outstandingCapabilitiesRequest =
                            this.requestCapabilitiesInternal(capabilities);
                        return [4 /*yield*/, this.outstandingCapabilitiesRequest];
                    case 5:
                        _b.sent();
                        return [3 /*break*/, 7];
                    case 6:
                        this.outstandingCapabilitiesRequest = undefined;
                        return [7 /*endfinally*/];
                    case 7: return [2 /*return*/];
                }
            });
        });
    };
    WidgetApiImpl.prototype.requestCapabilitiesInternal = function (capabilities) {
        return __awaiter(this, void 0, void 0, function () {
            var rawCapabilities, requestedSet, capabilities$;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        rawCapabilities = unique(convertToRawCapabilities(capabilities));
                        // Take shortcut if possible, that avoid extra roundtrips over the API.
                        if (this.hasCapabilities(rawCapabilities)) {
                            return [2 /*return*/];
                        }
                        requestedSet = new Set(rawCapabilities);
                        capabilities$ = fromEvent(this.matrixWidgetApi, "action:".concat(WidgetApiToWidgetAction.NotifyCapabilities), function (ev) { return ev; }).pipe(
                        // TODO: `hasCapability` in the matrix-widget-api isn't consistent when capability
                        //       upgrades happened. But `updateRequestedCapabilities` will deduplicate already
                        //       approved capabilities, so the the `requested` field will be inconsistent.
                        //       If we would enable this check, the function will never resolve. This should
                        //       be reactivated once the capability upgrade is working correctly. See also:
                        //       https://github.com/matrix-org/matrix-widget-api/issues/52
                        // Ignore events from other parallel capability requests
                        //filter((ev) =>
                        //  equalsSet(new Set(ev.detail.data.requested), requestedSet)
                        //),
                        map(function (ev) {
                            var approvedSet = new Set(ev.detail.data.approved);
                            var missingSet = subtractSet(requestedSet, approvedSet);
                            if (missingSet.size > 0) {
                                throw new Error("Capabilities rejected: ".concat(Array.from(missingSet).join(', ')));
                            }
                        }), first());
                        // eslint-disable-next-line no-async-promise-executor
                        return [4 /*yield*/, new Promise(function (resolve, reject) { return __awaiter(_this, void 0, void 0, function () {
                                var subscription, err_1;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            subscription = capabilities$.subscribe({
                                                next: resolve,
                                                error: reject,
                                            });
                                            _a.label = 1;
                                        case 1:
                                            _a.trys.push([1, 3, , 4]);
                                            this.matrixWidgetApi.requestCapabilities(rawCapabilities);
                                            return [4 /*yield*/, this.matrixWidgetApi.updateRequestedCapabilities()];
                                        case 2:
                                            _a.sent();
                                            return [3 /*break*/, 4];
                                        case 3:
                                            err_1 = _a.sent();
                                            subscription.unsubscribe();
                                            reject(err_1);
                                            return [3 /*break*/, 4];
                                        case 4: return [2 /*return*/];
                                    }
                                });
                            }); })];
                    case 1:
                        // eslint-disable-next-line no-async-promise-executor
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /** {@inheritDoc WidgetApi.hasCapabilities} */
    WidgetApiImpl.prototype.hasCapabilities = function (capabilities) {
        var _this = this;
        var rawCapabilities = convertToRawCapabilities(capabilities);
        return rawCapabilities.every(function (c) { return _this.matrixWidgetApi.hasCapability(c); });
    };
    /** {@inheritDoc WidgetApi.receiveSingleStateEvent} */
    WidgetApiImpl.prototype.receiveSingleStateEvent = function (eventType_1) {
        return __awaiter(this, arguments, void 0, function (eventType, stateKey) {
            var events;
            if (stateKey === void 0) { stateKey = ''; }
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.receiveStateEvents(eventType, { stateKey: stateKey })];
                    case 1:
                        events = _a.sent();
                        return [2 /*return*/, events && events[0]];
                }
            });
        });
    };
    /** {@inheritDoc WidgetApi.receiveStateEvents} */
    WidgetApiImpl.prototype.receiveStateEvents = function (eventType_1) {
        return __awaiter(this, arguments, void 0, function (eventType, _a) {
            var unvalidatedEvents, validatedEvents;
            var _b = _a === void 0 ? {} : _a, stateKey = _b.stateKey, roomIds = _b.roomIds;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0: return [4 /*yield*/, this.matrixWidgetApi.readStateEvents(eventType, Number.MAX_SAFE_INTEGER, stateKey, typeof roomIds === 'string' ? [Symbols.AnyRoom] : roomIds)];
                    case 1:
                        unvalidatedEvents = (_c.sent());
                        validatedEvents = unvalidatedEvents.filter(isValidStateEvent);
                        return [2 /*return*/, validatedEvents];
                }
            });
        });
    };
    /** {@inheritDoc WidgetApi.observeStateEvents} */
    WidgetApiImpl.prototype.observeStateEvents = function (eventType, _a) {
        var _b = _a === void 0 ? {} : _a, stateKey = _b.stateKey, roomIds = _b.roomIds;
        var currentRoomId = this.widgetParameters.roomId;
        if (!currentRoomId) {
            return throwError(function () { return new Error('Current room id is unknown'); });
        }
        var historyEvent$ = from(this.receiveStateEvents(eventType, { stateKey: stateKey, roomIds: roomIds })).pipe(mergeAll());
        var futureEvent$ = this.events$.pipe(map(function (event) {
            var matrixEvent = event.detail.data;
            if (matrixEvent.type === eventType &&
                matrixEvent.state_key !== undefined &&
                (stateKey === undefined || matrixEvent.state_key === stateKey) &&
                isInRoom(matrixEvent, currentRoomId, roomIds)) {
                return event.detail.data;
            }
            return undefined;
        }), filter(isDefined));
        return concat(historyEvent$, futureEvent$).pipe(filter(isValidStateEvent));
    };
    /** {@inheritDoc WidgetApi.sendStateEvent} */
    WidgetApiImpl.prototype.sendStateEvent = function (eventType, content, _a) {
        var _b = _a === void 0 ? {} : _a, roomId = _b.roomId, _c = _b.stateKey, stateKey = _c === void 0 ? '' : _c;
        return this.matrixWidgetApi.sendStateEvent(eventType, stateKey, content, roomId);
    };
    /** {@inheritDoc WidgetApi.sendDelayedStateEvent} */
    WidgetApiImpl.prototype.sendDelayedStateEvent = function (eventType_1, content_1, delay_1) {
        return __awaiter(this, arguments, void 0, function (eventType, content, delay, _a) {
            var delay_id;
            var _b = _a === void 0 ? {} : _a, roomId = _b.roomId, _c = _b.stateKey, stateKey = _c === void 0 ? '' : _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0: return [4 /*yield*/, this.matrixWidgetApi.sendStateEvent(eventType, stateKey, content, roomId, delay)];
                    case 1:
                        delay_id = (_d.sent()).delay_id;
                        if (!delay_id) {
                            throw new Error('Delayed event must have a delay_id');
                        }
                        return [2 /*return*/, { delay_id: delay_id }];
                }
            });
        });
    };
    /** {@inheritDoc WidgetApi.receiveRoomEvents} */
    WidgetApiImpl.prototype.receiveRoomEvents = function (eventType_1) {
        return __awaiter(this, arguments, void 0, function (eventType, _a) {
            var unvalidatedEvents, validatedEvents;
            var _b = _a === void 0 ? {} : _a, messageType = _b.messageType, roomIds = _b.roomIds;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0: return [4 /*yield*/, this.matrixWidgetApi.readRoomEvents(eventType, Number.MAX_SAFE_INTEGER, messageType, typeof roomIds === 'string' ? [Symbols.AnyRoom] : roomIds)];
                    case 1:
                        unvalidatedEvents = (_c.sent());
                        validatedEvents = unvalidatedEvents.filter(isValidRoomEvent);
                        return [2 /*return*/, validatedEvents];
                }
            });
        });
    };
    /** {@inheritDoc WidgetApi.observeRoomEvents} */
    WidgetApiImpl.prototype.observeRoomEvents = function (eventType, _a) {
        var _b = _a === void 0 ? {} : _a, messageType = _b.messageType, roomIds = _b.roomIds;
        var currentRoomId = this.widgetParameters.roomId;
        if (!currentRoomId) {
            return throwError(function () { return new Error('Current room id is unknown'); });
        }
        var historyEvent$ = from(this.receiveRoomEvents(eventType, { messageType: messageType, roomIds: roomIds })).pipe(mergeAll());
        var futureEvent$ = this.events$.pipe(map(function (event) {
            var matrixEvent = event.detail.data;
            if (matrixEvent.type === eventType &&
                matrixEvent.state_key === undefined &&
                (!messageType || matrixEvent.content.msgtype === messageType) &&
                isInRoom(matrixEvent, currentRoomId, roomIds)) {
                return event.detail.data;
            }
            return undefined;
        }), filter(isDefined));
        return concat(historyEvent$, futureEvent$).pipe(filter(isValidRoomEvent));
    };
    /** {@inheritDoc WidgetApi.sendRoomEvent} */
    WidgetApiImpl.prototype.sendRoomEvent = function (eventType_1, content_1) {
        return __awaiter(this, arguments, void 0, function (eventType, content, _a) {
            var subject, subscription, _b, event_id_1, room_id_1, event_1;
            var _c = _a === void 0 ? {} : _a, roomId = _c.roomId;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        subject = new ReplaySubject();
                        subscription = this.events$.subscribe(function (e) { return subject.next(e); });
                        _d.label = 1;
                    case 1:
                        _d.trys.push([1, , 4, 5]);
                        return [4 /*yield*/, this.matrixWidgetApi.sendRoomEvent(eventType, content, roomId)];
                    case 2:
                        _b = _d.sent(), event_id_1 = _b.event_id, room_id_1 = _b.room_id;
                        return [4 /*yield*/, firstValueFrom(subject.pipe(filter(function (event) {
                                var matrixEvent = event.detail.data;
                                return (matrixEvent.event_id === event_id_1 &&
                                    matrixEvent.room_id === room_id_1);
                            }), map(function (event) { return event.detail.data; })))];
                    case 3:
                        event_1 = _d.sent();
                        return [2 /*return*/, event_1];
                    case 4:
                        subscription.unsubscribe();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /** {@inheritDoc WidgetApi.sendDelayedRoomEvent} */
    WidgetApiImpl.prototype.sendDelayedRoomEvent = function (eventType_1, content_1, delay_1) {
        return __awaiter(this, arguments, void 0, function (eventType, content, delay, _a) {
            var delay_id;
            var _b = _a === void 0 ? {} : _a, roomId = _b.roomId;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0: return [4 /*yield*/, this.matrixWidgetApi.sendRoomEvent(eventType, content, roomId, delay)];
                    case 1:
                        delay_id = (_c.sent()).delay_id;
                        if (!delay_id) {
                            throw new Error('Delayed event must have a delay_id');
                        }
                        return [2 /*return*/, { delay_id: delay_id }];
                }
            });
        });
    };
    /** {@inheritDoc WidgetApi.updateDelayedEvent} */
    WidgetApiImpl.prototype.updateDelayedEvent = function (delayId, action) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.matrixWidgetApi.updateDelayedEvent(delayId, action)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /** {@inheritDoc WidgetApi.readEventRelations} */
    WidgetApiImpl.prototype.readEventRelations = function (eventId, options) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, chunk, next_batch;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.matrixWidgetApi.readEventRelations(eventId, options === null || options === void 0 ? void 0 : options.roomId, options === null || options === void 0 ? void 0 : options.relationType, options === null || options === void 0 ? void 0 : options.eventType, options === null || options === void 0 ? void 0 : options.limit, options === null || options === void 0 ? void 0 : options.from, undefined, options === null || options === void 0 ? void 0 : options.direction)];
                    case 1:
                        _a = _b.sent(), chunk = _a.chunk, next_batch = _a.next_batch;
                        return [2 /*return*/, {
                                chunk: chunk,
                                nextToken: next_batch !== null && next_batch !== void 0 ? next_batch : undefined,
                            }];
                }
            });
        });
    };
    /** {@inheritDoc WidgetApi.sendToDeviceMessage} */
    WidgetApiImpl.prototype.sendToDeviceMessage = function (eventType, encrypted, content) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.matrixWidgetApi.sendToDevice(eventType, encrypted, content)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /** {@inheritDoc WidgetApi.observeToDeviceMessages} */
    WidgetApiImpl.prototype.observeToDeviceMessages = function (eventType) {
        return this.toDeviceMessages$.pipe(map(function (e) { return e.detail.data; }), filter(isValidToDeviceMessageEvent), filter(function (e) { return e.type === eventType; }));
    };
    /** {@inheritDoc WidgetApi.openModal} */
    WidgetApiImpl.prototype.openModal = function (pathName, name, options) {
        return __awaiter(this, void 0, void 0, function () {
            var isModal, url, closeModalWidget$;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        isModal = parseWidgetId(this.widgetId).isModal;
                        if (isModal) {
                            throw new Error("Modals can't be opened from another modal widget");
                        }
                        url = generateWidgetRegistrationUrl({
                            pathName: pathName,
                            widgetParameters: this.widgetParameters,
                        });
                        return [4 /*yield*/, this.matrixWidgetApi.openModalWidget(url, name, options === null || options === void 0 ? void 0 : options.buttons, options === null || options === void 0 ? void 0 : options.data)];
                    case 1:
                        _a.sent();
                        closeModalWidget$ = fromEvent(this.matrixWidgetApi, "action:".concat(WidgetApiToWidgetAction.CloseModalWidget), function (event) {
                            var _a;
                            event.preventDefault();
                            _this.matrixWidgetApi.transport.reply(event.detail, {});
                            if (((_a = event.detail.data) === null || _a === void 0 ? void 0 : _a['m.exited']) === true) {
                                return undefined;
                            }
                            return event.detail.data;
                        });
                        return [2 /*return*/, firstValueFrom(closeModalWidget$)];
                }
            });
        });
    };
    /** {@inheritDoc WidgetApi.setModalButtonEnabled} */
    WidgetApiImpl.prototype.setModalButtonEnabled = function (buttonId, isEnabled) {
        return __awaiter(this, void 0, void 0, function () {
            var isModal;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        isModal = parseWidgetId(this.widgetId).isModal;
                        if (!isModal) {
                            throw new Error('Modal buttons can only be enabled from a modal widget');
                        }
                        return [4 /*yield*/, this.matrixWidgetApi.setModalButtonEnabled(buttonId, isEnabled)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /** {@inheritDoc WidgetApi.observeModalButtons} */
    WidgetApiImpl.prototype.observeModalButtons = function () {
        var _this = this;
        var isModal = parseWidgetId(this.widgetId).isModal;
        if (!isModal) {
            throw new Error('Modal buttons can only be observed from a modal widget');
        }
        return fromEvent(this.matrixWidgetApi, "action:".concat(WidgetApiToWidgetAction.ButtonClicked), function (event) {
            event.preventDefault();
            _this.matrixWidgetApi.transport.reply(event.detail, {});
            return event.detail.data.id;
        });
    };
    /** {@inheritDoc WidgetApi.closeModal} */
    WidgetApiImpl.prototype.closeModal = function (data) {
        return __awaiter(this, void 0, void 0, function () {
            var isModal;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        isModal = parseWidgetId(this.widgetId).isModal;
                        if (!isModal) {
                            throw new Error('Modals can only be closed from a modal widget');
                        }
                        return [4 /*yield*/, this.matrixWidgetApi.closeModalWidget(data ? data : { 'm.exited': true })];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /** {@inheritdoc WidgetApi.navigateTo} */
    WidgetApiImpl.prototype.navigateTo = function (uri) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.matrixWidgetApi.navigateTo(uri)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /** {@inheritdoc WidgetApi.requestOpenIDConnectToken} */
    WidgetApiImpl.prototype.requestOpenIDConnectToken = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!this.outstandingOpenIDConnectTokenRequest) return [3 /*break*/, 4];
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.outstandingOpenIDConnectTokenRequest];
                    case 2:
                        _b.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        _b.sent();
                        return [3 /*break*/, 4];
                    case 4:
                        _b.trys.push([4, , 6, 7]);
                        this.outstandingOpenIDConnectTokenRequest =
                            this.requestOpenIDConnectTokenInternal();
                        return [4 /*yield*/, this.outstandingOpenIDConnectTokenRequest];
                    case 5: return [2 /*return*/, _b.sent()];
                    case 6:
                        this.outstandingOpenIDConnectTokenRequest = undefined;
                        return [7 /*endfinally*/];
                    case 7: return [2 /*return*/];
                }
            });
        });
    };
    WidgetApiImpl.prototype.requestOpenIDConnectTokenInternal = function () {
        return __awaiter(this, void 0, void 0, function () {
            var leywayMilliseconds, openIdToken, err_2;
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        leywayMilliseconds = 30 * 1000;
                        if (this.cachedOpenIdToken &&
                            this.cachedOpenIdToken.expiresAt - leywayMilliseconds > Date.now()) {
                            return [2 /*return*/, this.cachedOpenIdToken.openIdToken];
                        }
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.matrixWidgetApi.requestOpenIDConnectToken()];
                    case 2:
                        openIdToken = _b.sent();
                        this.cachedOpenIdToken = {
                            openIdToken: openIdToken,
                            expiresAt: Date.now() + ((_a = openIdToken.expires_in) !== null && _a !== void 0 ? _a : 0) * 1000,
                        };
                        return [2 /*return*/, openIdToken];
                    case 3:
                        err_2 = _b.sent();
                        this.cachedOpenIdToken = undefined;
                        throw err_2;
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /** {@inheritdoc WidgetApi.observeTurnServers} */
    WidgetApiImpl.prototype.observeTurnServers = function () {
        return from(this.matrixWidgetApi.getTurnServers()).pipe(
        // For some reason a different naming was chosen for the API, but
        // we already convert them to the right type for WebRTC consumers.
        map(function (_a) {
            var uris = _a.uris, username = _a.username, password = _a.password;
            return ({
                urls: uris,
                username: username,
                credential: password,
            });
        }));
    };
    /** {@inheritdoc WidgetApi.searchUserDirectory}  */
    WidgetApiImpl.prototype.searchUserDirectory = function (searchTerm, options) {
        return __awaiter(this, void 0, void 0, function () {
            var results;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.matrixWidgetApi.searchUserDirectory(searchTerm, options === null || options === void 0 ? void 0 : options.limit)];
                    case 1:
                        results = (_a.sent()).results;
                        return [2 /*return*/, {
                                results: results.map(function (_a) {
                                    var user_id = _a.user_id, display_name = _a.display_name, avatar_url = _a.avatar_url;
                                    return ({
                                        userId: user_id,
                                        displayName: display_name,
                                        avatarUrl: avatar_url,
                                    });
                                }),
                            }];
                }
            });
        });
    };
    /** {@inheritdoc WidgetApi.getMediaConfig}  */
    WidgetApiImpl.prototype.getMediaConfig = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.matrixWidgetApi.getMediaConfig()];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /** {@inheritdoc WidgetApi.uploadFile}  */
    WidgetApiImpl.prototype.uploadFile = function (file) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.matrixWidgetApi.uploadFile(file)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /** {@inheritdoc WidgetApi.downloadFile}  */
    WidgetApiImpl.prototype.downloadFile = function (contentUrl) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.matrixWidgetApi.downloadFile(contentUrl)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    return WidgetApiImpl;
}());

export { ROOM_EVENT_REDACTION, STATE_EVENT_POWER_LEVELS, STATE_EVENT_ROOM_MEMBER, WIDGET_CAPABILITY_NAVIGATE, WidgetApiImpl, WidgetParameter, calculateUserPowerLevel, compareOriginServerTS, extractRawWidgetParameters, extractWidgetApiParameters, extractWidgetParameters, generateRoomTimelineCapabilities, generateWidgetRegistrationUrl, getContent, getOriginalEventId, getRoomMemberDisplayName, hasActionPower, hasRoomEventPower, hasStateEventPower, hasWidgetParameters, isRoomEvent, isStateEvent, isValidEventWithRelatesTo, isValidPowerLevelStateEvent, isValidRedactionEvent, isValidRoomEvent, isValidRoomMemberStateEvent, isValidStateEvent as isValidStateEVent, isValidToDeviceMessageEvent, makeEventFromSendStateEventResult, navigateToRoom, observeRedactionEvents, parseWidgetId, redactEvent, repairWidgetRegistration, sendStateEventWithEventResult };
